# 一、Java基础

**1.什么是装箱和拆箱？**  
装箱：基本数据类型转换为包装器类型，如int类型转为Integer类型  
拆箱：相反  

**2.Java的四个基本特性及多态的理解**  
Java的四个基本特性：
- 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包含数据抽象和行为抽象两个方面，抽象值关注对象有哪些属性和行为，并不关心这些行为的细节是什么  
- 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被父类（超类、基类）；得到继承信息的类被称为子类。  
- 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。  
- 多态：是指允许不同的子类的对象对同一消息作出不同的响应。   
多态的实现方式：方法重载、方法重写  
- 项目中多态的应用：在物流管理系统中，有两种用户：订购客户和卖家客户，两个客户都可以登录系统，他们有相同的方法Login，但登录之后他们会进入到不同的页面，也就是在登录的时候会有不同的操作，两种客户都继承分类的Login方法，但对于不同的对象拥有不同的操作。  

**3.重载和重写的区别？**
- 重载：Java中的方法重载发生在同一个类里面的两个或者多个方法的方法名相同，但是参数不同的情况。  
（1）可以是在一个类中，也可以是在继承关系的类中  
（2）名相同  
（3）参数列表不同（个数、顺序、类型）和方法的返回值类型无关  
- 重写：方法重写是说子类重新定义了父类的方法。方法重写必须有相同的方法名，参数列表和返回值类型。  
（1）不能存在在同一个类中，在继承或实现关系的类中；  
（2）名相同，参数列表相同，方法返回值相同；  
（3）子类方法的访问修饰符要大于父类的；  
（4）子类和检查异常要小于父类的检查异常。
- 附加：Java中不可以重写private或者static的方法。  

**4.String、StringBuffer和StringBuilder的区别？**  
（1）都是final类，都不允许继承；  
（2）String长度是不可变得，StringBuffer和StringBuilder长度是可变的；  
（3）StringBuffer是线程安全的，StringBuilder不是线程安全的，但它们两个中的方法都是相同的，StringBuffer的方法添加了synchronized修饰，保证了线程安全；  
（4）StringBuilder比StringBuffer拥有更好的性能。 
~~~java
String s1 = new String("abc");
String s2 = new String("abc");
System.out.println(s1 == s2); // false
String s3 = s1.intern();  //方法取得一个字符串引用
String s4 = s2.intern();
System.out.println(s3 == s4);  // true
~~~

**5.String中的"+"是如何实现的？**
~~~java
String c = "xx" + "yy " + a;
String d = new StringBuilder("xxyy ").append(a).toString();
//底层通过StringBuilder实现
~~~

**6.Java是如何进行文件读取的？Files常用方法**  
如果读取的是"abcdef"，要取出每个字母存到数组中，用FileReader.read()方法  
如果读取的是文件中的单词，可以使用BufferedReader中的readLine()方法  
Files.exists()：检测文件路径是否存在  
Files.createFile()：创建文件  
Files.read()：读取文件  
Files.write()：写入文件  

**7.static和final**  
**static**  
- **修饰变量：**  静态变量随着类加载时被完成初始化，内存中只有一个，且JVM也只会分配一次内存，所有类共享静态变量。  
- **修饰方法：**  在类加载的时候就存在，不依赖任何实例，static方法必须实现，不能用abstract修饰。  
- **修饰代码块：**  在类加载完之后就会执行代码块中的内容。  

**final**  
- final关键字提高了性能。final变量可以安全的在多线程环境下进行共享。
- **修饰变量：**  
编译期常量：类加载的过程完成初始化，编译后带入到任何计算式中，只能是基本类型。  
运行时常量：基本数据类型或引用数据类型。引用不可变，但引用的对象内容可变。
- **修饰方法：** 不能被继承，不能被子类修改。  
- **修饰类：** 不能被继承。
- **修饰形参：** final形参不可变。  

**8.基础的数据类型**  
8种：byte、boolean、char、short、int、float、long、double，String属于对象。  
**9.String类的常用方法都有哪些？**  
 indexOf()：返回指定字符的索引  
 charAt()：返回指定索引处的字符  
 replace()：字符串替换  
 split()：分割字符串，返回一个分割后的字符串数组
 length()：返回字符串长度  
 substring()：截取字符串  
 equals()：字符串比较  
 
 **10.接口和抽象类有什么区别？**  
 - interface定义接口，接口方法是隐式抽象的，不必使用abstract关键字；
 - 接口的成员(字段、方法)默认都是public的，并且不允许定义为private、protected；
 - 接口的字段默认都是static、final的；
 - 实现：抽象类的子类使用extends来继承；接口必须使用 implements 来实现接口；  
 - 构造函数：抽象类可以有构造函数；接口不能有；  
 - main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法；    
 - 实现数量：类可以实现很多个接口；但是只能继承一个抽象类；  
 - 访问修饰符：接口中的方法默认使用public修饰；抽象类中的方法可以是任意访问修饰符。   
 
 **11.java中IO流分几种？**  
按功能分：输入流（input）、输出流（output）  
按类型分：字节流和字符流  
**12.BIO、NIO、AIO有什么区别？**  
- BIO：Block IO 同步阻塞式IO，就是我们平常使用的传统IO，它的特点是模式简单使用方便，并发处理能力低；  
- NIO：New IO 同步非阻塞IO，是传统IO的升级，客户端和服务器端通过Channel（通道）通讯，实现了多路复用；  
- AIO：Asynchronous IO是NIO的升级，也叫NIO2，实现了异步非堵塞IO，异步IO的操作基于事件和回调机制。

**13.异常--throw和throws的区别？**  
throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。  

**14.final、finally、finalize 有什么区别？**  
- finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。
- finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize()，回收垃圾。

**15.try-catch-finally中哪个部分可以省略？**  
catch可以省略， 原因：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。  

**16.try-catch-finally 中，如果catch中return了，finally还会执行吗？**  
会执行，在 return 前执行。  

**17.常见的异常有哪些？**  
NullPointerException：当应用程序试图访问空对象时，则抛出该异常。  
IndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。  
NumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。  
FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。  

**18.this关键字和super关键字？** 
this：指向对象本身的一个指针；可以直接引用；形参与成员名字重名，用this来区分；引用构造函数；  
super：指向自己超（父）类对象的一个指针；与this类似，super相当于是指向当前对象的父类；子类中的成员变量或方法与父类中的成员变量或方法同名，用super区分。

# 二、容器  
**1.java容器有哪些？**  
Collection下：List有[Vector、ArrayList、LiskedList]、Queue、Set有[HashSet、TreeSet]、Map有[HashMap、TreeMap]  

**2.Collection和Collections的区别？**  
- java.util.Collection是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。  
- Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。  

**3.List、Set、Map之间的区别？**  

比较 | List | Set | Map
---|---|---|---
继承接口 | Collection | Collection |
常见实现类 | 子类有（ArrayList、Vector） | HashSet | HashMap、HashTable  
常见方法 | add() remove() clear() get() | add() remove() clear() | put() get() containsKey()  
元素 | 可重复 | 不可重复（用equals判断） | key不可重复  
顺序 | 有序 | 无序 | 无序
线程安全 | Vector线程安全 |  | HashTable线程安全  

**4.HashMap和HashTable的区别？**  
- 线程安全：HashTable是线程安全的
- hashMap去掉了HashTable的contains方法，但是加上了containsValue（）和containsKey（）方法  
- 效率：hashTable同步的，而HashMap是非同步的，效率上比hashTable要高
- hashMap允许空键值，而hashTable不允许
- 底层数据结构  

**5.说下HashMap的实现原理？**  
- HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。HashMap的数据结构："链表散列"的数据结构，即数组和链表的结合体。JDK1.8中，当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率。
- 例子：当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,然后用根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,（拉链法解决冲突）那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。  

**6.ArrayList 和 LinkedList 的区别是什么？**  
底层的数据结构：ArrayList是数组，支持随机访问；LinkedList是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList的时间复杂度是 O(1)，而LinkedList是 O(n)。 

**7.如何实现数组和List之间的转换？**  
a.List转换成为数组：调用ArrayList的toArray方法  
b.数组转换成为List：调用Arrays的asList方法  

**8.ArrayList 和 Vector 的区别是什么?**  
Vector是同步的，而ArrayList不是。ArrayList比Vector快，ArrayList更加通用，可以使用Collections工具类轻易地获取同步列表和只读列表。  
**9.Array 和 ArrayList 有何区别？**  
- Array可以容纳基本类型和对象，而ArrayList只能容纳对象。  
- Array是指定大小的，而ArrayList大小是动态变化的。  
- Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。  

**10.迭代器Iterator是什么？有什么特点？怎么使用？**  
迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。  
使用方法：  
a.使用方法iterator()要求容器返回一个Iterator对象。  
b.使用next()获得序列中的下一个元素。  
c.使用hasNext()检查序列中是否还有元素。  
d.使用remove()将迭代器新返回的元素删除。  

# 三、多线程  
**1.并行与并发的区别？**  
- 并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。  
- 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。  

**2.进程与线程的区别？**  
进程是程序运行和资源分配的基本单位，线程是进程的一个实体，是cpu调度和分派的基本单位。一个程序至少有一个进程，一个进程至少有一个线程。 

**3.创建线程有哪几种方法？**  
1）继承Thread类创建线程类  
a.定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。  
b.创建Thread子类的实例，即创建了线程对象。  
c.调用线程对象的start()方法来启动该线程。  
2）通过Runnable接口创建线程类  
a.定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。  
b.创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。  
c.调用线程对象的start()方法来启动该线程。  
3）通过Callable和Future创建线程  
a.创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。  
b.创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。  
c.使用FutureTask对象作为Thread对象的target创建并启动新线程。  
d.调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。  

**4.说下runnable和callable有什么区别？**  
a.Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；  
b.Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。  

**5.线程有哪些状态？**  
线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。 
- 创建状态：在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。
- 就绪状态：当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。  
- 运行状态：线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。  
- 阻塞状态：线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep、suspend、wait等方法都可以导致线程阻塞。
- 死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪。  

**6.sleep() 和 wait() 有什么区别？**  
sleep()方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。  
wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程。  

**7.创建线程池有哪几种方法？**  
1）newFixedThreadPool(int nThreads)  
创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。  
2）newCachedThreadPool()  
创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。  
3）newSingleThreadExecutor()  
这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。  
4）newScheduledThreadPool(int corePoolSize)  
创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。  

**8.线程池都有哪些状态？**  
线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。  
**9.什么是死锁？**  
死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。  

**9.怎么防止死锁？**  
死锁的4个必要条件：  
a.互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源。  
b.请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放。  
c.不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放。  
d.环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系。  

**10.ThreadLocal 是什么？有哪些使用场景？**  
线程局部变量是局限于线程内部的变量，属于线程自身所有。

**11.说一下 synchronized 底层实现原理？**  
synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。  

**12.synchronized和volatile的区别是什么？**  
- volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。
- volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。
- volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
- volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。 

**13.synchronized和ReentrantLock区别是什么？**  
synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。所以类可以被继承、可以有方法、类变量，ReentrantLock的扩展性体现在在：
a.ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁   
b.ReentrantLock可以获取各种锁的信息  
c.ReentrantLock可以灵活地实现多路通知   

**14.说一下Atomic的原理？**  
- Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。  
- Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。  

**15.并发编程的3个概念(特性)?**  
- 原子性：即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。  
- 可见性：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。  
- 有序性：即程序执行的顺序按照代码的先后顺序执行。  

**16.什么是线程安全？**   
就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。  
# 四、反射  
**1.什么是反射？**  
反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。  

**2.什么是java序列化？什么情况下需要序列化？**  
序列化就是保存对象状态的机制。即为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。  
下面3中情况需要序列化：  
a.当你想把内存中的对象状态保存到一个文件中或者数据库中时候；  
b.当你想用套接字在网络上传送对象的时候；  
c.当你想通过RMI传输对象的时候；  

**3.动态代理是什么意思？有哪些应用？**  
当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。  
动态代理的应用：Spring的AOP、加事务、加权限、加日志。  

# 五、对象拷贝
**1.为什么要使用克隆？**  
想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。  

**2.如何实现对象的克隆？**  
2种方式：
1）实现Cloneable接口并重写Object类中的clone()方法；  
2）实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下： 

**3.深拷贝和浅拷贝区别是什么？**  
- 浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）  
- 深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）  

****
# 六、Java Web
**1.说下session的工作原理？**  
session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。类似于一个大号的map吧，里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中取出对应的值了。 

**2.如果客户端禁止cookie，session还能用吗？**  
不能，因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。

**3.如何避免sql注入？**  
a.PreparedStatement  
b.使用正则表达式过滤传入的参数  
c.字符串过滤  
d.JSP中调用该函数检查是否包函非法字符  
**4.什么是XXS攻击，如何避免？**  
XSS攻击又称CSS,全称Cross-Site-Script（跨站脚本攻击），其原理是攻击者向有XSS漏洞的网站中输入恶意的 HTML 代码，当用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。XSS防范的总体思路是：对输入(和URL参数)进行过滤，对输出进行编码。  

**5.什么是 CSRF 攻击，如何避免？**  
跨站请求伪造：一般来说，攻击者通过伪造用户的浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令。  
避免方法：  
a.验证HTTP Referer字段  b.使用验证码  c.在请求地址中添加token并验证
****
#### 七、网络
**1.session和cookie的区别？**
- session在服务端，cookie在浏览器  
- cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗  
- session会在一定时间内保存在服务器上，当访问增多，会比较占用服务器的性能。  
  
**2.http中状态消息200、301、302、304、403、404、500分别表示什么?**  
200：请求成功  
301、302：都表示某个URL发生了转移，区别在于：
301：永久性转移  302：暂时性转移  
304：自从上次请求后，请求的网页未修改过。  
404：服务器找不到请求的网页。  
500：服务器错误

**3.简述TCP和UDP的区别？**  
- TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。
- TCP提供可靠的服务。
- UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
- 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。
- TCP对系统资源要求较多，UDP对系统资源要求较少。  

**4.TCP为什么要三次握手，两次不行吗？为什么**  
为了实现可靠的数据传输，TCP协议的通信双方都必须维护一个序列号，一标志发送出去的数据包中，哪些是已经被对方收到。三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤。如果只是两次握手，至多只有连接发起方的起始序列号能被确认，另一方选择的序列号则得不到确认。  

**5.OSI的七层模型都有哪些？**  

**6.get和post请求有哪些区别？**  
GET在浏览器回退时是无害的，而POST会再次提交请求。  
GET产生的URL地址可以被Bookmark，而POST不可以。  
GET请求只能进行url编码，而POST支持多种编码方式。  
GET请求在URL中传送的参数是有长度限制的，而POST没有。  

****  

# 八、Spring、Spring MVC
**1.Spring的特点？**  
1）轻量  
2）控制反转：Spring通过一种称作控制反转（IoC）的技术促进了松耦合。  
3）面向切面：Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。  
4）容器：Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。  
5）框架：Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。  

**2.什么是IOC？**  
大体观点：借助于“第三方”[即IOC容器]实现具有依赖关系的对象之间的解耦。  
IoC是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。IoC容器实际就是一个Map，Map中存放的是各种对象。  
将对象之间的相互依赖关系交给IoC容器来管理，并由IoC容器完成对象的注入。这样可以很大程度上简化应用的开发。IoC容器像个工厂，当需要创建一个对象的时候，只需配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来。  
Spring IoC的初始化过程： 
```
graph LR
XML--读取-->Resource
Resource--解析-->BeanDefinition
BeanDefinition--注册-->BeanFactory
```

**3.什么是AOP？**  
AOP（Aspect-Oriented Programming，面向方面编程），是OOP（面向对象编程）的补充和完善。AOP就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。  
Spring AOP是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用JDK Proxy去进行代理了，这时候Spring AOP会使用Cglib生成一个被代理对象的子类来作为代理，如下图：  
![Image](https://github.com/iamdsyang/MyPic/blob/master/AOP_Spring.png)

**4.Spring有哪些主要模块？**  
主要有：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。   

**5.Spring常用的注入方式有哪些？**  
Spring通过DI（依赖注入）实现IOC（控制反转），常用的注入方式主要有三种：
a.构造方法注入 b.setter注入 c.基于注解的注入  

**6.Spring 中的 bean 是线程安全的吗？**  
容器本身并没有提供Bean的线程安全策略  

**7.Spring 支持几种 bean 的作用域？**  
当通过spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下5种作用域：  
- singleton：单例模式  
- prototype：原型模式  
- request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效。  
- session：对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。  

**8.spring 自动装配 bean 有哪些方式？**  
Spring容器负责创建应用程序中的bean同时通过ID来协调这些对象之间的关系。  
Spring中bean装配有两种方式：  
a.隐式的bean发现机制和自动装配  b.在java代码或者XML中进行显示配置  

**9.Spring事务实现方式有哪些？**  
a.编程式事务管理对基于POJO的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。  
b.基于TransactionProxyFactoryBean 的声明式事务管理  
c.基于@Transactional的声明式事务管理  
d.基于Aspectj AOP配置事务  

**10.说说Spring MVC运行流程？**  
1）用户向服务器发送请求，请求被Spring前端控制Servelt DispatcherServlet捕获；  
2）DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象，最后以HandlerExecutionChain对象的形式返回；
3）DispatcherServlet根据获得的Handler，选择一个合适的HandlerAdapter；  
4）提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：

**11.spring mvc有哪些组件？**  
- DispatcherServlet：中央控制器，把请求给转发到具体的控制类
- Controller：具体处理请求的控制器
- HandlerMapping：映射处理器，负责映射中央处理器转发给controller时的映射策略
- ModelAndView：服务层返回的数据和视图层的封装类
- ViewResolver：视图解析器，解析具体的视图
- Interceptors ：拦截器，负责拦截我们定义的请求然后做处理工作

**12.@RequestMapping 的作用是什么？**  
RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。  
RequestMapping注解有六个属性，下面我们把它分成三类进行说明。  
value， method：  
- value：指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；
- method：指定请求的method类型， GET、POST、PUT、DELETE等；

consumes，produces：  
- consumes：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html；  
- produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；  

params，headers：  
- params： 指定request中必须包含某些参数值是，才让该方法处理。  
- headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。  

**13.@Autowired 的作用是什么？**  

# 九、Spring Boot、Spring Cloud
**1.为什么要用 spring boot？**  
Spring Boot使编码、配置、部署、监控变简单。  

**2.spring boot 核心配置文件是什么？**  
properties文件、yml文件，相对于properties文件而言，yml通过空格来确定层级关系，使配置文件结构跟清晰，但也会因为微不足道的空格而破坏了层级关系。  

**3.Spring Boot的启动和运行原理？**  


**4.Spring boot 有哪些方式可以实现热部署？**  
a.使用spring loaded  在配置文件中添加依赖  
b.使用spring-boot-devtools 在项目的pom文件中添加依赖  

**5.jpa和hibernate有什么区别？**  


**6.什么是spring cloud？**  
Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具，如：配置管理、服务注册与发现、断路由、负载均衡、分布式会话等等。  
**7.断路由的作用是什么？**  

**8.spring cloud的核心组件有哪些？**  
服务发现---Netflix Eureka  
客服端负载均衡——Netflix Ribbon  
断路器——Netflix Hystrix  
服务网关——Netflix Zuul  

# 十、Mybatis


# 十一、Redis

# 十二、MySQL-数据库
**1.数据库的事务？**  
事务指的是满足 ACID 特性的一组操作，可以通过Commit提交一个事务，也可以使用Rollback进行回滚。  
**2.说说ACID？**  
- 原子性(Atomicity)：事务的所有操作要么全部提交成功，要么全部失败回滚。
- 一致性(Consistency)：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。
- 隔离性(Isolation)：一个事务所做的修改在最终提交以前，对其它事务是不可见的。
- 持久性(Durability)：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。  

**3.并发一致性问题？**  
a.数据丢失修改：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。  
b.脏读：T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。  
c.不可重复读：T2 读取一个数据，T1对该数据做了修改。如果T2再次读取这个数据，此时读取的结果和第一次读取的结果不同。  
d.幻影读：T1 读取某个范围的数据，T2在这个范围内插入新的数据，T1再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。  

**4.事务的实现原理通过什么来保证事务的特性?**  
封锁

**5.什么是左连接、右连接、什么是全连接、什么是内连接？**  
在内连接的基础上，左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。  
内连接是把匹配的关联数据显示出来；   
全连接：两个表合并


**6.数据库的索引有什么用、用什么来实现、好坏处是什么？**  
作用:索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而**实现高效查找数据**。
实现：B+树，B+树的搜索效率，可以到达二分法的性能  
B+树原理：
a.数据结构
b.操作(查找操作、插入删除操作)

**7.数据库的三大范式？**  
第一范式：原子性每列不可再拆分    
第二范式：不产生局部依赖
第三范式：不产生传递依赖  
反三范式：为了提高数据的性能、增加冗余字段，以便提高查询性能



